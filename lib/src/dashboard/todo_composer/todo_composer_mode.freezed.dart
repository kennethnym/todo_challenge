// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'todo_composer_mode.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TodoComposerModeTearOff {
  const _$TodoComposerModeTearOff();

  Hidden hidden() {
    return const Hidden();
  }

  AddTodo addTodo() {
    return const AddTodo();
  }

  ViewTodo viewTodo(Todo selectedTodo) {
    return ViewTodo(
      selectedTodo,
    );
  }

  EditTodo editTodo(Todo todo) {
    return EditTodo(
      todo,
    );
  }
}

/// @nodoc
const $TodoComposerMode = _$TodoComposerModeTearOff();

/// @nodoc
mixin _$TodoComposerMode {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hidden,
    required TResult Function() addTodo,
    required TResult Function(Todo selectedTodo) viewTodo,
    required TResult Function(Todo todo) editTodo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Hidden value) hidden,
    required TResult Function(AddTodo value) addTodo,
    required TResult Function(ViewTodo value) viewTodo,
    required TResult Function(EditTodo value) editTodo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TodoComposerModeCopyWith<$Res> {
  factory $TodoComposerModeCopyWith(
          TodoComposerMode value, $Res Function(TodoComposerMode) then) =
      _$TodoComposerModeCopyWithImpl<$Res>;
}

/// @nodoc
class _$TodoComposerModeCopyWithImpl<$Res>
    implements $TodoComposerModeCopyWith<$Res> {
  _$TodoComposerModeCopyWithImpl(this._value, this._then);

  final TodoComposerMode _value;
  // ignore: unused_field
  final $Res Function(TodoComposerMode) _then;
}

/// @nodoc
abstract class $HiddenCopyWith<$Res> {
  factory $HiddenCopyWith(Hidden value, $Res Function(Hidden) then) =
      _$HiddenCopyWithImpl<$Res>;
}

/// @nodoc
class _$HiddenCopyWithImpl<$Res> extends _$TodoComposerModeCopyWithImpl<$Res>
    implements $HiddenCopyWith<$Res> {
  _$HiddenCopyWithImpl(Hidden _value, $Res Function(Hidden) _then)
      : super(_value, (v) => _then(v as Hidden));

  @override
  Hidden get _value => super._value as Hidden;
}

/// @nodoc

class _$Hidden implements Hidden {
  const _$Hidden();

  @override
  String toString() {
    return 'TodoComposerMode.hidden()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Hidden);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hidden,
    required TResult Function() addTodo,
    required TResult Function(Todo selectedTodo) viewTodo,
    required TResult Function(Todo todo) editTodo,
  }) {
    return hidden();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
  }) {
    return hidden?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
    required TResult orElse(),
  }) {
    if (hidden != null) {
      return hidden();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Hidden value) hidden,
    required TResult Function(AddTodo value) addTodo,
    required TResult Function(ViewTodo value) viewTodo,
    required TResult Function(EditTodo value) editTodo,
  }) {
    return hidden(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
  }) {
    return hidden?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
    required TResult orElse(),
  }) {
    if (hidden != null) {
      return hidden(this);
    }
    return orElse();
  }
}

abstract class Hidden implements TodoComposerMode {
  const factory Hidden() = _$Hidden;
}

/// @nodoc
abstract class $AddTodoCopyWith<$Res> {
  factory $AddTodoCopyWith(AddTodo value, $Res Function(AddTodo) then) =
      _$AddTodoCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddTodoCopyWithImpl<$Res> extends _$TodoComposerModeCopyWithImpl<$Res>
    implements $AddTodoCopyWith<$Res> {
  _$AddTodoCopyWithImpl(AddTodo _value, $Res Function(AddTodo) _then)
      : super(_value, (v) => _then(v as AddTodo));

  @override
  AddTodo get _value => super._value as AddTodo;
}

/// @nodoc

class _$AddTodo implements AddTodo {
  const _$AddTodo();

  @override
  String toString() {
    return 'TodoComposerMode.addTodo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is AddTodo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hidden,
    required TResult Function() addTodo,
    required TResult Function(Todo selectedTodo) viewTodo,
    required TResult Function(Todo todo) editTodo,
  }) {
    return addTodo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
  }) {
    return addTodo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
    required TResult orElse(),
  }) {
    if (addTodo != null) {
      return addTodo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Hidden value) hidden,
    required TResult Function(AddTodo value) addTodo,
    required TResult Function(ViewTodo value) viewTodo,
    required TResult Function(EditTodo value) editTodo,
  }) {
    return addTodo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
  }) {
    return addTodo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
    required TResult orElse(),
  }) {
    if (addTodo != null) {
      return addTodo(this);
    }
    return orElse();
  }
}

abstract class AddTodo implements TodoComposerMode {
  const factory AddTodo() = _$AddTodo;
}

/// @nodoc
abstract class $ViewTodoCopyWith<$Res> {
  factory $ViewTodoCopyWith(ViewTodo value, $Res Function(ViewTodo) then) =
      _$ViewTodoCopyWithImpl<$Res>;
  $Res call({Todo selectedTodo});
}

/// @nodoc
class _$ViewTodoCopyWithImpl<$Res> extends _$TodoComposerModeCopyWithImpl<$Res>
    implements $ViewTodoCopyWith<$Res> {
  _$ViewTodoCopyWithImpl(ViewTodo _value, $Res Function(ViewTodo) _then)
      : super(_value, (v) => _then(v as ViewTodo));

  @override
  ViewTodo get _value => super._value as ViewTodo;

  @override
  $Res call({
    Object? selectedTodo = freezed,
  }) {
    return _then(ViewTodo(
      selectedTodo == freezed
          ? _value.selectedTodo
          : selectedTodo // ignore: cast_nullable_to_non_nullable
              as Todo,
    ));
  }
}

/// @nodoc

class _$ViewTodo implements ViewTodo {
  const _$ViewTodo(this.selectedTodo);

  @override
  final Todo selectedTodo;

  @override
  String toString() {
    return 'TodoComposerMode.viewTodo(selectedTodo: $selectedTodo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ViewTodo &&
            (identical(other.selectedTodo, selectedTodo) ||
                const DeepCollectionEquality()
                    .equals(other.selectedTodo, selectedTodo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(selectedTodo);

  @JsonKey(ignore: true)
  @override
  $ViewTodoCopyWith<ViewTodo> get copyWith =>
      _$ViewTodoCopyWithImpl<ViewTodo>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hidden,
    required TResult Function() addTodo,
    required TResult Function(Todo selectedTodo) viewTodo,
    required TResult Function(Todo todo) editTodo,
  }) {
    return viewTodo(selectedTodo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
  }) {
    return viewTodo?.call(selectedTodo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
    required TResult orElse(),
  }) {
    if (viewTodo != null) {
      return viewTodo(selectedTodo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Hidden value) hidden,
    required TResult Function(AddTodo value) addTodo,
    required TResult Function(ViewTodo value) viewTodo,
    required TResult Function(EditTodo value) editTodo,
  }) {
    return viewTodo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
  }) {
    return viewTodo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
    required TResult orElse(),
  }) {
    if (viewTodo != null) {
      return viewTodo(this);
    }
    return orElse();
  }
}

abstract class ViewTodo implements TodoComposerMode {
  const factory ViewTodo(Todo selectedTodo) = _$ViewTodo;

  Todo get selectedTodo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ViewTodoCopyWith<ViewTodo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditTodoCopyWith<$Res> {
  factory $EditTodoCopyWith(EditTodo value, $Res Function(EditTodo) then) =
      _$EditTodoCopyWithImpl<$Res>;
  $Res call({Todo todo});
}

/// @nodoc
class _$EditTodoCopyWithImpl<$Res> extends _$TodoComposerModeCopyWithImpl<$Res>
    implements $EditTodoCopyWith<$Res> {
  _$EditTodoCopyWithImpl(EditTodo _value, $Res Function(EditTodo) _then)
      : super(_value, (v) => _then(v as EditTodo));

  @override
  EditTodo get _value => super._value as EditTodo;

  @override
  $Res call({
    Object? todo = freezed,
  }) {
    return _then(EditTodo(
      todo == freezed
          ? _value.todo
          : todo // ignore: cast_nullable_to_non_nullable
              as Todo,
    ));
  }
}

/// @nodoc

class _$EditTodo implements EditTodo {
  const _$EditTodo(this.todo);

  @override
  final Todo todo;

  @override
  String toString() {
    return 'TodoComposerMode.editTodo(todo: $todo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EditTodo &&
            (identical(other.todo, todo) ||
                const DeepCollectionEquality().equals(other.todo, todo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(todo);

  @JsonKey(ignore: true)
  @override
  $EditTodoCopyWith<EditTodo> get copyWith =>
      _$EditTodoCopyWithImpl<EditTodo>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hidden,
    required TResult Function() addTodo,
    required TResult Function(Todo selectedTodo) viewTodo,
    required TResult Function(Todo todo) editTodo,
  }) {
    return editTodo(todo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
  }) {
    return editTodo?.call(todo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hidden,
    TResult Function()? addTodo,
    TResult Function(Todo selectedTodo)? viewTodo,
    TResult Function(Todo todo)? editTodo,
    required TResult orElse(),
  }) {
    if (editTodo != null) {
      return editTodo(todo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Hidden value) hidden,
    required TResult Function(AddTodo value) addTodo,
    required TResult Function(ViewTodo value) viewTodo,
    required TResult Function(EditTodo value) editTodo,
  }) {
    return editTodo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
  }) {
    return editTodo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Hidden value)? hidden,
    TResult Function(AddTodo value)? addTodo,
    TResult Function(ViewTodo value)? viewTodo,
    TResult Function(EditTodo value)? editTodo,
    required TResult orElse(),
  }) {
    if (editTodo != null) {
      return editTodo(this);
    }
    return orElse();
  }
}

abstract class EditTodo implements TodoComposerMode {
  const factory EditTodo(Todo todo) = _$EditTodo;

  Todo get todo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EditTodoCopyWith<EditTodo> get copyWith =>
      throw _privateConstructorUsedError;
}
